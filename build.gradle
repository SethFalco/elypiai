buildscript {
	repositories {
		mavenCentral()
	}

	dependencies {
		classpath 'org.junit.platform:junit-platform-gradle-plugin:1.1.0'
	}
}

plugins {
	id "com.jfrog.bintray" version "1.8.0"
}

apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'org.junit.platform.gradle.plugin'
apply plugin: 'maven'
apply plugin: 'maven-publish'

String projectName = 'Elypiai'
String projectVersion = '1.0.3'

jar {
	from sourceSets.main.allSource

	manifest {
		attributes 	'Implementation-Title'	 : projectName,
					'Implementation-Version' : projectVersion
	}
}

task sourcesJar(type: Jar, dependsOn: classes) {
	classifier = 'sources'
	from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: javadoc) {
	classifier = 'javadoc'
	from javadoc.destinationDir
}

artifacts {
	archives sourcesJar
	archives javadocJar
}

bintray {
	user = System.getenv('BINTRAY_USER')
	key = System.getenv('BINTRAY_KEY')
	publications = ['Elypiai']

	pkg {
		repo = projectName
		name = projectName
		userOrg = 'elypia'
		licenses = ['Apache-2.0']
		vcsUrl = 'https://gitlab.com/Elypia/' + projectName + '.git'

		version {
			name = projectVersion
			desc = 'All in one API wrapper.'
			released = new Date()
		}
	}
}

def pomConfig = {
	licenses {
		license {
			name 'The Apache Software License, Version 2.0'
			url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
			distribution projectName
		}
	}

	developers {
		developer {
			id 'Seth'
			name 'Seth'
			email "seth@elypia.com"
		}
	}

	scm {
		url 'https://gitlab.com/Elypia/Elypiai.git'
	}
}

publishing {
	publications {
		Elypiai(MavenPublication) {
			from components.java
			artifact sourcesJar
			artifact javadocJar
			groupId 'com.elypia'
			artifactId 'elypiai'
			version projectVersion

			pom.withXml {
				def root = asNode()
				root.appendNode('description', 'All in one API wrapper.')
				root.appendNode('name', projectName)
				root.appendNode('url', 'https://elypia.com/')
				root.children().last() + pomConfig
			}
		}
	}
}

repositories {
	jcenter()
}

dependencies {
	implementation group: 'org.jsoup', name: 'jsoup', version: '1.11.2'
	implementation group: 'org.json', name: 'json', version: '20180130'
    implementation 'com.squareup.okhttp3:okhttp:3.10.0'
	implementation group: 'commons-codec', name: 'commons-codec', version: '1.11'

	testImplementation group: 'org.mockito', name: 'mockito-core', version: '2.15.0'
    testImplementation 'com.squareup.okhttp3:mockwebserver:3.10.0'
	testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: '5.1.0'

	testRuntimeOnly group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: '5.1.0'
	testRuntimeOnly group: 'org.junit.platform', name: 'junit-platform-runner', version: '1.1.0'
}

compileJava {
	options.compilerArgs += '-Xlint:unchecked'
}

junitPlatform {
	details 'tree'
}

task wrapper(type: Wrapper) {
	description = 'Generates gradlew[.bat] scripts'
	gradleVersion = '4.6'
}

import groovy.io.FileType

import java.util.regex.Matcher
import java.util.regex.Pattern

class SecretTask extends DefaultTask {

	@TaskAction
	void search() {
		final File currentDirectory = new File(".")
		final List<File> files = new ArrayList<>()

		currentDirectory.eachFileRecurse(FileType.FILES) { file ->
			String name = file.getCanonicalPath()

			if (!name.contains("Test") && name.endsWith(".java"))
				files << file
		}

		files.each { file ->
			boolean failed
			List<String> lines

			try {
				lines = file.readLines()
			} catch (IOException) {
				System.err.printf("Unable to read: '%s'%n", file.getCanonicalPath())
				return
			}

			Map<String, Pattern> patterns = new HashMap<>()
			patterns.put("Discord Bot Token", Pattern.compile(/(?i)[A-Z\d]{24}\.[A-Z\d-_]{6}\.[A-Z\d-_]{27}/))
			patterns.put("Amazon Access Key", Pattern.compile(/AKIA[IJ][A-Z2-7]{14}[AQ]/))
			patterns.put("Amazon Secret", Pattern.compile(/(?i)\b[A-Z\d\/+]{40}\b/))
			patterns.put("Steam API Key", Pattern.compile(/[A-F\d]{32}/))

			for (int i = 0; i < lines.size(); i++) {
				patterns.forEach { name, pattern ->
					Matcher match = pattern.matcher(lines[i])

					while (match.find()) {
						String message = "Found %s at: '%s' line: %d%n"
						System.err.printf(message, name, file.getCanonicalPath(), i + 1)
						failed = true
					}
				}
			}

			if (failed) {
				String message = "Found secrets in the code, read logs and revoke these ASAP."
				throw new GradleScriptException(message, null)
			}
		}
	}
}

task search(type: SecretTask)
